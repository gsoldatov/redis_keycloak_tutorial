+ KeyCloak container:
    + pass params from configuration;
    + setup programmatically:
        ++ add & delete app realm;
        ++ add & delete client;
        ++ add & delete roles;
        ++ add & delete users;
    + ensure realm & user configuration persists container being stopped;
    x add healthcheck to docker run command to check if container is up;
    + expose healthcheck port;

+ CLI utility for containers:
    + run:
        + runs Keycloak container;
        + performs initial configuration of keycloak;
    + stop:
        + stops Keycloak container;
    + remove:
        + removes Keycloak container;

+ web app:
    + auth routes:
        + login:
            + gets a new token from Keycloak & returns it;
            + handles network errors;
            + handles incorrect credentials;
        + logout;
    + app routes:
        + protected (first role);
        + protected (second role);

+ tests:
    + fixtures:
        + config;
        + KC container;
        + wait for Keycloak to be ready;
        + test config (custom KC realm);
        + test KC realm & data (drop in teardown);
        + async test client (app without cache);
        + async test client (app without cache & with "disabled" keycloak); # or override dependency KC service dependency
    
    + tests:
        + login:
            + validation;
            + network error;
            + disabled user;
            + invalid credentials;
            + successful login;
        + logout:
            + network error;
            + missing token;
            + invalid token:
                + wrong format;
                x add a role, which does not exist;
            + expired token;
            x token of a disabled user;
            + successful logout;
        + first protected route:
            + network error when validating token;
            + missing token;
            + invalid token format;
            + expired token;
            + token without required role;
            + valid request with a correct token;
            + valid request with a refreshed token;
        + second protected route:
            + network error when validating token;
            + missing token;
            + invalid token format;
            + expired token;
            + token without required role;
            + valid request with a correct token;
            + valid request with a refreshed token;

x limit scope to app_client when logging in;

+ Keycloak:
    + change app roles:
        x add `can_login` or use default role/setting;
        + add `can_post`;

+ setup Redis container:
    + add configuration;
    + add container manager;
    + add to CLI;

- Redis-using routes, tests & misc:
    + change routes:
        + add /auth prefix to auth routes;
        + add /misc prefix to test routes;
    
    // redis.io/docs/latest/develop/clients/patterns/twitter-clone/

    + /auth/register route:
        + validates provided credentials;
        + passes provided credentials to Keycloak;
        + returns 503, if Keycloak is unavailable;
        + returns 400, if user was not created;
        + adds data of the new user to the database;
        + returns 503, if Redis is unavailable;
        + returns 201;
    
    + test fixtures:
        x add key prefix for all Redis keys to support running tests;
        
        + rename fixtures;

        + config fixture for unavailable Keycloak & Redis:
            + add Redis settings;
            + change scope to module;
        
        + add a shared test state manager class;    // use a file lock https://py-filelock.readthedocs.io/en/latest/index.html
        + add a session fixute for resetting the shared state;

        + add a fixture for obtaining a Redis database number:
            + use a file lock to read currently used database number, increment it and write new state;
            x store an array of released database numbers:
                x append to it when module tests are done;
                x pop from it before incrementing the counter;
                x do not exceed maximum database number from the config;
                x retry, if counter reached max value and no released number are available;

        + test config fixture:
            + module-scoped;
            + set test Redis settings (db number & network);
        
        + Redis client fixture:
            + module-scoped;
            + ensures Redis is up;
            + connects to the correct DB;
        
        + app & client fixtures with Keycloak & Redis available:
            + add Redis DB cleanup after tests;
        
        + config fixture for Redis unavailable:
            + module-scoped;
            + ensures Keycloak is available;
        
        + app & client fixtures for Redis unavailable;
        
    + /auth/register tests:
        + validation;
        + keycloak network error;
        + redis network error;
        + existing email;
        + existing username;
        + successful registration;
    
    + rename KeycloakManager & keycloak_manager + keycloak/setup.py;

    + add error middleware:
        + catch existing exceptions:
            + split AuthException into exceptions, which result in 400 & 401 responses;
        + catch other exceptions:
            + log;
            + return 500;
    
    x proparage subprocess errors during container operations;      // requires running individual healthchecks for each container
    
    // returns user info
    + GET /users/:username route:
        + returns public user info from the database;
        + returns 404 if user not found;
    
    + GET /users/:username tests:
        + username validation;
        + Redis network error => 503;
        + username validation is executed;
        + non-existing user => 404;
        + existing user => 200 + correct user data;
    
    + refactor validation tests:
        + run all validation tests against Pydantic models + run a single route test for check if validation works;
    
    // adds a user follower
    + PUT /users/:username/followers/:follower:
        + validates user token:
            + returns 401, if token does not exist;
            + returns 401, if token does not have a `preferred_username` attribute;
            + retuns 403, if token was not issued for `follower`;
        + returns 404 if `username` or `follower` does not exist;
        + returns 400, if trying to self-follow;
        + adds `follower` to the followers sorted set of `username`;
        + adds posts of `username` to the feed of `follower`;
    
    + PUT /users/:username/followers/:follower:
        + keycloak network exception;
        + redis network exception;
        + validation is triggered;
        + invalid access token;
        + valid token of another user;
        + non-existing followed username;
        + self-following is not allowed;
        + valid follower add operation (followers set):
            + create 3 users;
            + add 2nd & 3rd as followers of 1st;
            + check if responses have correct code;
            + check if 1st user has 2 followers in the database;
        + valid follower add operation (follower feed);
            + create 4 users;
            + create posts for 2nd, 3rd & 4th users;
            + add 1st user as a follower of 2nd and 3rd;
            + check if responses have correct code;
            + check feed of 1st user contains posts of 2nd and 3rd;
    
    // removes a user follower
    + DELETE /users/:username/followers/:follower:
        + validates user token:
            + returns 401, if token does not exist;
            + returns 401, if token does not have a `preferred_username` attribute;
            + retuns 403, if token was issued for another user;
        + returns 404 if `username` or `follower` does not exist;
        + returns 400, if trying to self-follow;
        + removes `follower` from the followers sorted set of `username`;
        + removes posts of `username` from the feed of `follower`;        
        + retunrs 200 if `follower` does not follow `username`;

        + tests:
            + keycloak network exception;
            + redis network exception;
            + validation is triggered;
            + invalid access token;
            + valid token of another user;
            + non-existing followed username;
            + self-unfollowing is not allowed;
            + valid follower remove operation (followers set);
            + valid follower remove operation (removing a non-existing follower);
            + valid follower remove operation (follower feed);
    
    // returns paginated user followers
    + GET /users/:username/followers:
        + gets optional `last_viewed` integer URL param;
        + returns 404 if `username` does not exist;
        + returns a paginated list of followers of `username`:
            + starting after `last_viewed`, if provided;
            + from the start of the list, if not;
            + returns 404 if no followers were found;
        
        + tests:
            + redis network exception;
            + `username` & `last_viewed` validation;
            + non-existing `username`;
            + empty follower list without `last_viewed`;
            + empty follower list with `last_viewed`;
            + follower list without `list_viewed`;
            + follower list with `list_viewed`;
            + follower list without `list_viewed` > number of followers;
    
    // adds a new post of a user
    + POST /users/:username/posts:
        + validates user token:
            + returns 401, if token does not exist;
            + returns 403, if token was issued for another user;
            + returns 403, if token does not have `can-post` role;
        + validates user post body;
        + adds post data;
        + adds the post to the list of user posts;
        + adds the post to the feeds of user's followers;

        + tests:
            + post data validation;
            + keycloak network error;
            + redis network error;
            + validation is triggered;
            + invalid access token;
            + access token without `can-post` role;
            + access token of another user;
            + add posts (posts are properly saved);
            + add posts (post is added to author's posts);
            + add posts (posts are properly added to the followers feeds);
    
    // Returns a post
    + GET /posts/:post_id:
        + validates post_id;
        + returns 404 if a post does not exist;
        + returns a post, if it exists;

        + tests:
            + redis network error;
            + post_id validation;
            + non-existing post;
            + existing post;
    
    // returns paginated posts of user
    + GET /users/:username/posts:
        + gets optional `last_viewed` integer URL param;
        + returns 404 if `username` does not exist;
        + returns a paginated list of posts of `username`:
            + starting after `last_viewed`, if provided;
            + from the start of the list, if not;
            + returns 404 if no followers were found;
        
        + tests:
            + redis connection error;
            + username & last_viewed validation;
            + non-existing username;
            + posts of a user without posts;
            + posts of a user with posts;

    + reverse post score, so that newer posts are fetched first;
    
    // returns paginated feed of user
    + GET /users/:username/feed:
        + gets optional `last_viewed` integer URL param;
        + returns 404 if `username` does not exist;
        + returns a paginated list of posts of `username`:
            + starting after `last_viewed`, if provided;
            + from the start of the list, if not;
            + returns 404 if no followers were found;
        
        + tests:
            + redis connection error;
            + username & last_viewed validation;
            + non-existing username;
            + feed without posts;
            + feed with posts;

+ Redis keys & values:
    + user:$username: hash with data of $username;
    + user_followers:$username: sorted set with IDs of followers of $username;
    + user_feed:$username: sorted set with post IDs of users, followed by $username;
    + user_posts:$username: list of post IDs of $username posts;
    + id_next_post: ID of next created post;
    + post:$post_id: data of $post_id;

- move Redis client methods into nested attributes;
? move access/refresh tokens store to Redis;

- allow logging in only via email (forbid using username) & add tests;
